进程：
	独享内存空间

线程：
	无符号长整形 %lu
	共享进程资源

	创建进程 -> 运行时段
	编译需要连接线程库 -lpthread
	pthread_create()
	pthread_exit()
	pthread_join()
	线程清理函数
	pthread_clean_push()
	pthread_clean_pop()
	线程锁
		静态锁：
			pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER
		动态锁：
			pthread_mutex_init()
			pthread_mutex_destroy()

		加锁：
			pthread_mutex_lock
		解锁：
			pthread_mutex_unlock
==========================================
net:
	网络编程：就是通过套接子进行进程之间通讯的一种编程。	

	网络模型：描述网络的结构原理和工作原理
	OSI ：开发系统互联参考模型
	由底到高：
		物理层：
		数据链路层：
		网络层：
		传输层：
		会话层：
		表示层：
		应用层：
		
		前三层为OSI参考模型的低三层，主要祝福网络通讯连接的链路
		后四层为OSI参考模型高四层， 主要负责端到端的数据通讯。

		1 物理层：检测物理电路，确保数据的发送。
		设备：集线器
				1 放大信号
				2 扩展物理接口。
		
		2 数据链路层：保证数据在物理线路上的可靠传输。
			该层作用包括物理编址、网络拓扑结构、错误校验、帧序列及流控。
			物理编址：定义设备早数据链路层的编址方式。
			网络拓扑结构：表示设备的物理连接方式，如总线拓扑结构或者环拓扑结构。
			错误校验：传输数据的时候发生错误向上层协议发送警告。
			数据帧序列：重新整理并传输序列。
			流控：可能延缓数据的传输，以使接受设备不会因为某一时刻的接受超过处理能力的信息而崩溃。
			设备：交换机
				通过对信息进行重新生成，并经过内部处理转发到指定端口，具备自动寻址和交换作用。

		3 网络层：
			将网络地址翻译成对应物理地址，也就是解析IP地址
			设备：路由器 网关
				具有地址翻译，协议转换和数据格式转换功能。
		4 传输层：
			实现不同用户之间的数据通讯 tcp udp
		5 会话层：保证数据链接
			会话层提供的服务可使应用建立和位置会话，并能使会话获得同步。
		6 表示层：
			数据的表现形式
			即提供格式化的表示和转换数据服务，数据压缩和解压缩，加密或者解密。

		7 应用层：
			数据用户接口，也就是应用层用户程序编辑接口。

	TCP/IP协议：
		TCP ：传输控制协议
		IP : 因特网互联协议 又名网络通讯协议

		1 主机到网络：涉及硬件组建
		2 网络互联层 ： 
			IP : 网络互联协议
			ICMP : 控制报文协议
			IGMP : 互联网组管理协议
			ARP :  地址解析协议 网络地址转换成物理地址
			RARP ：逆地址解析协议 物理地址转换成网络地址
		3 传输层
			TCP : 传输控制协议   必须保证双方都在线
			DDP : 用户数据报协议 一方负责发送，另一方负责接受。
		4 应用层：
			服务			


	数据传输通过Ethernet II帧格式
		最小长度64字节
		最大长度1518字节

		目标MAC地址(6) | 源MAC地址(6) | 类型(2) | 数据(46-1500) ｜ FCS(4)

		目标地址：确定帧的接收者
		源地址  ：发送帧的工作站。
		类型字段：告诉接收者如何解析数据字段
		数据	：
			数据帧：帧头  + IP数据包 + 帧尾
				帧头：主要包括源和目标主机MAC地址及类型
				帧尾：校验字
			IP数据包 ：IP包头 + TCP数据信息
				IP包头：源和目标主机IP地址， 类型，生存周期等等
			TCP数据信息：TCP头部+ 实际数据
				TCP头部：包括源和目标主机端口号，帧序列号 确认号，校验字等等。
	
	机器地址：MAC地址 物理地址 硬件地址
	
		共48比特，占6个字节，前面3个字节为厂商编号，后3个字节为网络适配号

		厂商编号是由IEEE指定
		网络适配号是由厂商编号

		IEEE : 电气电子工程师协议，是一个国际性的电子技术与信息科学工程师协会，是目前全球最大的非盈利性专业技术学会。

	windows : ipconfig /all
	linux : ifconfig eth0

	IP地址：
		现在最主流的IP地址版本是4,用32bit(4个Byte来表示一个地址,简称IPV4
		PV6的地址采用128bit(16Byte)来表示一个IP地址

		公有地址：I n t e r n e t地址
		A类：美国
			范围：0.0.0.0 ~ 127.255.255.255
			最大网络数：
				[root@aa 5_31]# echo $[2**7 -2]
				126
			最大主机数：
				[root@aa 5_31]# echo $[2**24 -2]
				16777214
			子网掩码: 255.0.0.0
		B类：欧洲
			128.0.0.0 ~ 191.255.255.255
		C类：亚洲
			192.0.0.0 ~ 223.255.255.255
		D类：多播地址
			224.0.0.0 ~ 239.255.255.255
		E类：保留
			240.0.0.0 ~ 247.255.255.255

		IP地址 = 网络号 + 主机号
		私有地址：局域网


	TCP实现通过三次握手机制来实现
	标志位：
		SYN : 建立连接
		ACK ：确认
		PSH ：传送
		FIN ：结束
		RST ：重置
		URG ：紧急
		
	第一次握手：
		建立连接。客户端发送一个SYN包（SYN => 1 ）,同时发送一个同步序列号X,发送给服务器。
		第二次握手：
		服务器接受到SYN包，确认是客户端发送，同时想客户端发送ACK包（ACK => 1） 同时也会发送一个序列号Y,并将客户端发送序列号的基础上+1, 然后将这个包发送给客户端。
		第三次握手：
		客户端接受到服务器ACK包，则将服务器发送序列号+1，SYN => 0, 将此包发送给服务器。然后服务器接受到这个包，则双方处理通讯状态。完成三次握手机制。



	客户端：
		1 创建套接子
		int socket(int domain, int type, int protocol);
		第一个参数：表示使用地址家族
			ipv4 => PF_INET
		第二个参数：表示数据类型
			SOCK_STREAM ： 表示流式套接子 tcp
			SOCK_DGRAM : 表示数据报套接子 udp
		第三个参数：表示使用协议
			tcp/ip协议  => 0
		返回值：
			成功：返回文件描述符
			失败：-1

		2 请求建立连接
		int  connect(int  sockfd,  const  struct sockaddr *serv_addr,
		       socklen_t addrlen);

		第一个参数：表示文件描述符
		第二个参数：表示目标地址
		struct sockaddr_in {
			sa_family_t    sin_family; /* address family: AF_INET */
				表示地址家族
			u_int16_t      sin_port;   /* port in network byte order */
				表示端口号
			struct in_addr sin_addr;   /* internet address */
				表示网络地址
		};

		 struct in_addr {
		              u_int32_t      s_addr;     /* address in network byte order */
					           };


	
	主机字节序：
	网络字节序：
	为什么要转换，是因为主机数据和网络数据存储方式不一致
	int a = 12345678

	高字节：数据而言，就是高位
	底字节：就是数据低位
	高地址：相对内存而言 
	底地址
	大端模式：网络一般用大端模式
		高字节存在底地址上，或者底字节存储在高地址
	小端模式：主机一般用的小端模式
		高字节存储在高地址 或者底字节存储在底地址

	主机字节序转换成网络字节序
	uint32_t htonl(uint32_t hostlong); 长整形
	uint16_t htons(uint16_t hostshort);短整形
	网络字节序转换成主机字节序
	uint32_t ntohl(uint32_t netlong); 长整形
	uint16_t ntohs(uint16_t netshort);短整形

	in_addr_t inet_addr(const char *cp);表示将ip地址转换二进制数字
	char *inet_ntoa(struct in_addr in); 表示将网络二进制数字转换成ip地址

	

	服务器：
		1 创建套接子

		2 帮定端口
		int   bind(int   sockfd,   const  struct  sockaddr  *my_addr,
		       socklen_t addrlen);
		第一个参数：表示套接子
		第二个参数：表示源地址
		第三个参数：地址长度
		返回值：成功 0
				失败 -1

		3 监听
		int listen(int sockfd, int backlog);
		第一个参数：就是套接子
		第二个参数：表示监听个数
	
		4 接受数据
		int  accept(int  sockfd,  struct  sockaddr  *addr,  socklen_t
		       *addrlen);
		第一个参数：表示套接子 socket返回值
		第二个参数：表示目标地址
		第三个参数：表示目标地址大小

		socket:只负责监听对方链接
		accept:负责发送和接受数据

		服务端口：由用户来指定的一个未被使用端口 0 ~ 65535
		数据端口：由kernel自动指定一个端口，用于数据传送。


		练习：
			实现tell:
		homework :
			实现ssh
			scp





